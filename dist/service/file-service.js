"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fileService = void 0;
const fs_1 = require("fs");
const glob_1 = __importDefault(require("glob"));
const path_1 = __importDefault(require("path"));
const ts_config_file_service_1 = require("src/service/convert/ts/ts-config-file-service");
const constant_1 = require("src/util/constant");
const _self = {
    fileListFromFolder: async (folderPath) => {
        return new Promise((resolve, reject) => {
            const cwd = _self.relativeToAbsPath(folderPath);
            glob_1.default('**/*', { cwd, dot: true, nodir: true, ignore: ['**/*.test.ts', '**/*.contract.ts'] }, (err, files) => {
                // TODO implement some mechanism to ignore files
                if (err)
                    return reject(err);
                return resolve(files.map((f) => _self.joinPaths(folderPath, f)));
            });
        });
    },
    makeFolderIfNotExist: async (folderPath) => {
        if (await fs_1.promises.stat(folderPath).catch(() => false))
            return;
        await fs_1.promises.mkdir(folderPath);
    },
    writeToFile: async (params) => {
        const { filePath, data } = params;
        await fs_1.promises.writeFile(filePath, data, 'utf-8');
    },
    readFile: async (filePath) => {
        return fs_1.promises.readFile(filePath, 'utf8');
    },
    mkdirAndWriteToFile: async (params) => {
        const { folderPath, fileName, data } = params;
        await _self.makeFolderIfNotExist(folderPath);
        await _self.writeToFile({ filePath: _self.joinPaths(folderPath, fileName), data });
    },
    joinPaths: (...paths) => {
        return path_1.default.join(...paths);
    },
    isAbsPath: (relativeOrAbsPath) => {
        return relativeOrAbsPath.startsWith(constant_1.constant.folderSep);
    },
    isDotPath: (path) => {
        return path.startsWith('.');
    },
    relativeToAbsPath: (relativeOrAbsPath) => {
        return _self.isAbsPath(relativeOrAbsPath) ? relativeOrAbsPath : _self.joinPaths(process.cwd(), relativeOrAbsPath);
    },
    cleanupPath: (relativeOrAbsPath) => {
        return path_1.default.join(relativeOrAbsPath);
    },
    lastFolderFromPath: (filePath) => {
        const pathSplit = filePath.split(constant_1.constant.folderSep);
        if (pathSplit[pathSplit.length - 1].includes('.'))
            pathSplit.pop();
        return pathSplit.join(constant_1.constant.folderSep);
    },
    importPathFind: (params) => {
        const { filePathImportedFrom, importPath } = params;
        const resolvedImportPath = ts_config_file_service_1.tsConfigFileService.moduleAliasResolve(importPath);
        const importedFromPath = _self.lastFolderFromPath(filePathImportedFrom);
        const importPathSplit = resolvedImportPath.split(constant_1.constant.folderSep);
        const importedFromPathReverseSplit = importedFromPath.split(constant_1.constant.folderSep).reverse();
        let equalPathSplitCount = 0;
        for (const [ix, split] of Object.entries(importPathSplit)) {
            if (importedFromPathReverseSplit[ix] !== split)
                break;
            equalPathSplitCount = +ix + 1;
        }
        const cleanImportPath = importPathSplit.slice(equalPathSplitCount).join(constant_1.constant.folderSep);
        return _self.joinPaths(importedFromPath, cleanImportPath);
    },
    fileNameFromPath: (filePath, options = {}) => {
        const parts = filePath.split(constant_1.constant.folderSep);
        const lastPart = parts[parts.length - 1];
        if (options.withExtension)
            return lastPart;
        const nameParts = lastPart.split('.');
        if (nameParts.length === 1)
            return nameParts[0];
        nameParts.pop();
        return nameParts.join('.');
    },
};
exports.fileService = _self;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZS1zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3NlcnZpY2UvZmlsZS1zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDJCQUFtQztBQUNuQyxnREFBdUI7QUFDdkIsZ0RBQXVCO0FBQ3ZCLDBGQUFtRjtBQUNuRixnREFBNEM7QUFFNUMsTUFBTSxLQUFLLEdBQUc7SUFDWixrQkFBa0IsRUFBRSxLQUFLLEVBQUUsVUFBa0IsRUFBcUIsRUFBRTtRQUNsRSxPQUFPLElBQUksT0FBTyxDQUFXLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO1lBQy9DLE1BQU0sR0FBRyxHQUFHLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsQ0FBQTtZQUMvQyxjQUFJLENBQUMsTUFBTSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsQ0FBQyxjQUFjLEVBQUUsa0JBQWtCLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxFQUFFO2dCQUN6RyxnREFBZ0Q7Z0JBQ2hELElBQUksR0FBRztvQkFBRSxPQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQTtnQkFDM0IsT0FBTyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO1lBQ2xFLENBQUMsQ0FBQyxDQUFBO1FBQ0osQ0FBQyxDQUFDLENBQUE7SUFDSixDQUFDO0lBQ0Qsb0JBQW9CLEVBQUUsS0FBSyxFQUFFLFVBQWtCLEVBQWlCLEVBQUU7UUFDaEUsSUFBSSxNQUFNLGFBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FB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UUFBQSxXQUFXLEdBQUcsS0FBSyxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcHJvbWlzZXMgYXMgZnMgfSBmcm9tICdmcydcbmltcG9ydCBnbG9iIGZyb20gJ2dsb2InXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJ1xuaW1wb3J0IHsgdHNDb25maWdGaWxlU2VydmljZSB9IGZyb20gJ3NyYy9zZXJ2aWNlL2NvbnZlcnQvdHMvdHMtY29uZmlnLWZpbGUtc2VydmljZSdcbmltcG9ydCB7IGNvbnN0YW50IH0gZnJvbSAnc3JjL3V0aWwvY29uc3RhbnQnXG5cbmNvbnN0IF9zZWxmID0ge1xuICBmaWxlTGlzdEZyb21Gb2xkZXI6IGFzeW5jIChmb2xkZXJQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHN0cmluZ1tdPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjd2QgPSBfc2VsZi5yZWxhdGl2ZVRvQWJzUGF0aChmb2xkZXJQYXRoKVxuICAgICAgZ2xvYignKiovKicsIHsgY3dkLCBkb3Q6IHRydWUsIG5vZGlyOiB0cnVlLCBpZ25vcmU6IFsnKiovKi50ZXN0LnRzJywgJyoqLyouY29udHJhY3QudHMnXSB9LCAoZXJyLCBmaWxlcykgPT4ge1xuICAgICAgICAvLyBUT0RPIGltcGxlbWVudCBzb21lIG1lY2hhbmlzbSB0byBpZ25vcmUgZmlsZXNcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpXG4gICAgICAgIHJldHVybiByZXNvbHZlKGZpbGVzLm1hcCgoZikgPT4gX3NlbGYuam9pblBhdGhzKGZvbGRlclBhdGgsIGYpKSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcbiAgbWFrZUZvbGRlcklmTm90RXhpc3Q6IGFzeW5jIChmb2xkZXJQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoYXdhaXQgZnMuc3RhdChmb2xkZXJQYXRoKS5jYXRjaCgoKSA9PiBmYWxzZSkpIHJldHVyblxuICAgIGF3YWl0IGZzLm1rZGlyKGZvbGRlclBhdGgpXG4gIH0sXG4gIHdyaXRlVG9GaWxlOiBhc3luYyAocGFyYW1zOiB7IGZpbGVQYXRoOiBzdHJpbmc7IGRhdGE6IHN0cmluZyB9KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgY29uc3QgeyBmaWxlUGF0aCwgZGF0YSB9ID0gcGFyYW1zXG4gICAgYXdhaXQgZnMud3JpdGVGaWxlKGZpbGVQYXRoLCBkYXRhLCAndXRmLTgnKVxuICB9LFxuICByZWFkRmlsZTogYXN5bmMgKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZShmaWxlUGF0aCwgJ3V0ZjgnKVxuICB9LFxuICBta2RpckFuZFdyaXRlVG9GaWxlOiBhc3luYyAocGFyYW1zOiB7IGZvbGRlclBhdGg6IHN0cmluZzsgZmlsZU5hbWU6IHN0cmluZzsgZGF0YTogc3RyaW5nIH0pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBjb25zdCB7IGZvbGRlclBhdGgsIGZpbGVOYW1lLCBkYXRhIH0gPSBwYXJhbXNcbiAgICBhd2FpdCBfc2VsZi5tYWtlRm9sZGVySWZOb3RFeGlzdChmb2xkZXJQYXRoKVxuICAgIGF3YWl0IF9zZWxmLndyaXRlVG9GaWxlKHsgZmlsZVBhdGg6IF9zZWxmLmpvaW5QYXRocyhmb2xkZXJQYXRoLCBmaWxlTmFtZSksIGRhdGEgfSlcbiAgfSxcbiAgam9pblBhdGhzOiAoLi4ucGF0aHM6IHN0cmluZ1tdKTogc3RyaW5nID0+IHtcbiAgICByZXR1cm4gcGF0aC5qb2luKC4uLnBhdGhzKVxuICB9LFxuICBpc0Fic1BhdGg6IChyZWxhdGl2ZU9yQWJzUGF0aDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgcmV0dXJuIHJlbGF0aXZlT3JBYnNQYXRoLnN0YXJ0c1dpdGgoY29uc3RhbnQuZm9sZGVyU2VwKVxuICB9LFxuICBpc0RvdFBhdGg6IChwYXRoOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICByZXR1cm4gcGF0aC5zdGFydHNXaXRoKCcuJylcbiAgfSxcbiAgcmVsYXRpdmVUb0Fic1BhdGg6IChyZWxhdGl2ZU9yQWJzUGF0aDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICByZXR1cm4gX3NlbGYuaXNBYnNQYXRoKHJlbGF0aXZlT3JBYnNQYXRoKSA/IHJlbGF0aXZlT3JBYnNQYXRoIDogX3NlbGYuam9pblBhdGhzKHByb2Nlc3MuY3dkKCksIHJlbGF0aXZlT3JBYnNQYXRoKVxuICB9LFxuICBjbGVhbnVwUGF0aDogKHJlbGF0aXZlT3JBYnNQYXRoOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIHJldHVybiBwYXRoLmpvaW4ocmVsYXRpdmVPckFic1BhdGgpXG4gIH0sXG4gIGxhc3RGb2xkZXJGcm9tUGF0aDogKGZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IHBhdGhTcGxpdCA9IGZpbGVQYXRoLnNwbGl0KGNvbnN0YW50LmZvbGRlclNlcClcbiAgICBpZiAocGF0aFNwbGl0W3BhdGhTcGxpdC5sZW5ndGggLSAxXS5pbmNsdWRlcygnLicpKSBwYXRoU3BsaXQucG9wKClcbiAgICByZXR1cm4gcGF0aFNwbGl0LmpvaW4oY29uc3RhbnQuZm9sZGVyU2VwKVxuICB9LFxuICBpbXBvcnRQYXRoRmluZDogKHBhcmFtczogeyBmaWxlUGF0aEltcG9ydGVkRnJvbTogc3RyaW5nOyBpbXBvcnRQYXRoOiBzdHJpbmcgfSk6IHN0cmluZyA9PiB7XG4gICAgY29uc3QgeyBmaWxlUGF0aEltcG9ydGVkRnJvbSwgaW1wb3J0UGF0aCB9ID0gcGFyYW1zXG4gICAgY29uc3QgcmVzb2x2ZWRJbXBvcnRQYXRoID0gdHNDb25maWdGaWxlU2VydmljZS5tb2R1bGVBbGlhc1Jlc29sdmUoaW1wb3J0UGF0aClcbiAgICBjb25zdCBpbXBvcnRlZEZyb21QYXRoID0gX3NlbGYubGFzdEZvbGRlckZyb21QYXRoKGZpbGVQYXRoSW1wb3J0ZWRGcm9tKVxuICAgIGNvbnN0IGltcG9ydFBhdGhTcGxpdCA9IHJlc29sdmVkSW1wb3J0UGF0aC5zcGxpdChjb25zdGFudC5mb2xkZXJTZXApXG4gICAgY29uc3QgaW1wb3J0ZWRGcm9tUGF0aFJldmVyc2VTcGxpdCA9IGltcG9ydGVkRnJvbVBhdGguc3BsaXQoY29uc3RhbnQuZm9sZGVyU2VwKS5yZXZlcnNlKClcbiAgICBsZXQgZXF1YWxQYXRoU3BsaXRDb3VudCA9IDBcbiAgICBmb3IgKGNvbnN0IFtpeCwgc3BsaXRdIG9mIE9iamVjdC5lbnRyaWVzKGltcG9ydFBhdGhTcGxpdCkpIHtcbiAgICAgIGlmIChpbXBvcnRlZEZyb21QYXRoUmV2ZXJzZVNwbGl0W2l4XSAhPT0gc3BsaXQpIGJyZWFrXG4gICAgICBlcXVhbFBhdGhTcGxpdENvdW50ID0gK2l4ICsgMVxuICAgIH1cbiAgICBjb25zdCBjbGVhbkltcG9ydFBhdGggPSBpbXBvcnRQYXRoU3BsaXQuc2xpY2UoZXF1YWxQYXRoU3BsaXRDb3VudCkuam9pbihjb25zdGFudC5mb2xkZXJTZXApXG4gICAgcmV0dXJuIF9zZWxmLmpvaW5QYXRocyhpbXBvcnRlZEZyb21QYXRoLCBjbGVhbkltcG9ydFBhdGgpXG4gIH0sXG4gIGZpbGVOYW1lRnJvbVBhdGg6IChmaWxlUGF0aDogc3RyaW5nLCBvcHRpb25zOiB7IHdpdGhFeHRlbnNpb24/OiBib29sZWFuIH0gPSB7fSk6IHN0cmluZyA9PiB7XG4gICAgY29uc3QgcGFydHMgPSBmaWxlUGF0aC5zcGxpdChjb25zdGFudC5mb2xkZXJTZXApXG4gICAgY29uc3QgbGFzdFBhcnQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXVxuICAgIGlmIChvcHRpb25zLndpdGhFeHRlbnNpb24pIHJldHVybiBsYXN0UGFydFxuICAgIGNvbnN0IG5hbWVQYXJ0cyA9IGxhc3RQYXJ0LnNwbGl0KCcuJylcbiAgICBpZiAobmFtZVBhcnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIG5hbWVQYXJ0c1swXVxuICAgIG5hbWVQYXJ0cy5wb3AoKVxuICAgIHJldHVybiBuYW1lUGFydHMuam9pbignLicpXG4gIH0sXG59XG5cbmV4cG9ydCBjb25zdCBmaWxlU2VydmljZSA9IF9zZWxmXG4iXX0=