"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fileService = void 0;
const fs_1 = require("fs");
const glob_1 = __importDefault(require("glob"));
const path_1 = __importDefault(require("path"));
const ts_config_file_service_1 = require("src/service/convert/ts/ts-config-file-service");
const constant_1 = require("src/util/constant");
const _self = {
    fileListFromFolder: async (folderPath) => {
        return new Promise((resolve, reject) => {
            const cwd = _self.relativeToAbsPath(folderPath);
            glob_1.default('**/*', { cwd, dot: true, nodir: true, ignore: '**/*.test.ts' }, (err, files) => {
                // TODO implement some mechanism to ignore files
                if (err)
                    return reject(err);
                return resolve(files.map((f) => _self.joinPaths(folderPath, f)));
            });
        });
    },
    makeFolderIfNotExist: async (folderPath) => {
        if (await fs_1.promises.stat(folderPath).catch(() => false))
            return;
        await fs_1.promises.mkdir(folderPath);
    },
    writeToFile: async (params) => {
        const { filePath, data } = params;
        await fs_1.promises.writeFile(filePath, data, 'utf-8');
    },
    readFile: async (filePath) => {
        return fs_1.promises.readFile(filePath, 'utf8');
    },
    mkdirAndWriteToFile: async (params) => {
        const { folderPath, fileName, data } = params;
        await _self.makeFolderIfNotExist(folderPath);
        await _self.writeToFile({ filePath: _self.joinPaths(folderPath, fileName), data });
    },
    joinPaths: (...paths) => {
        return path_1.default.join(...paths);
    },
    isAbsPath: (relativeOrAbsPath) => {
        return relativeOrAbsPath.startsWith(constant_1.constant.folderSep);
    },
    isDotPath: (path) => {
        return path.startsWith('.');
    },
    relativeToAbsPath: (relativeOrAbsPath) => {
        return _self.isAbsPath(relativeOrAbsPath) ? relativeOrAbsPath : _self.joinPaths(process.cwd(), relativeOrAbsPath);
    },
    cleanupPath: (relativeOrAbsPath) => {
        return path_1.default.join(relativeOrAbsPath);
    },
    lastFolderFromPath: (filePath) => {
        const pathSplit = filePath.split(constant_1.constant.folderSep);
        if (pathSplit[pathSplit.length - 1].includes('.'))
            pathSplit.pop();
        return pathSplit.join(constant_1.constant.folderSep);
    },
    importPathFind: (params) => {
        const { filePathImportedFrom, importPath } = params;
        const resolvedImportPath = ts_config_file_service_1.tsConfigFileService.moduleAliasResolve(importPath);
        const importedFromPath = _self.lastFolderFromPath(filePathImportedFrom);
        const importPathSplit = resolvedImportPath.split(constant_1.constant.folderSep);
        const importedFromPathReverseSplit = importedFromPath.split(constant_1.constant.folderSep).reverse();
        let equalPathSplitCount = 0;
        for (const [ix, split] of Object.entries(importPathSplit)) {
            if (importedFromPathReverseSplit[ix] !== split)
                break;
            equalPathSplitCount = +ix + 1;
        }
        const cleanImportPath = importPathSplit.slice(equalPathSplitCount).join(constant_1.constant.folderSep);
        return _self.joinPaths(importedFromPath, cleanImportPath);
    },
    fileNameFromPath: (filePath, options = {}) => {
        const parts = filePath.split(constant_1.constant.folderSep);
        const lastPart = parts[parts.length - 1];
        if (options.withExtension)
            return lastPart;
        const nameParts = lastPart.split('.');
        if (nameParts.length === 1)
            return nameParts[0];
        nameParts.pop();
        return nameParts.join('.');
    },
};
exports.fileService = _self;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZS1zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3NlcnZpY2UvZmlsZS1zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDJCQUFtQztBQUNuQyxnREFBdUI7QUFDdkIsZ0RBQXVCO0FBQ3ZCLDBGQUFtRjtBQUNuRixnREFBNEM7QUFFNUMsTUFBTSxLQUFLLEdBQUc7SUFDWixrQkFBa0IsRUFBRSxLQUFLLEVBQUUsVUFBa0IsRUFBcUIsRUFBRTtRQUNsRSxPQUFPLElBQUksT0FBTyxDQUFXLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO1lBQy9DLE1BQU0sR0FBRyxHQUFHLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsQ0FBQTtZQUMvQyxjQUFJLENBQUMsTUFBTSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsY0FBYyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLEVBQUU7Z0JBQ25GLGdEQUFnRDtnQkFDaEQsSUFBSSxHQUFHO29CQUFFLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFBO2dCQUMzQixPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7WUFDbEUsQ0FBQyxDQUFDLENBQUE7UUFDSixDQUFDLENBQUMsQ0FBQTtJQUNKLENBQUM7SUFDRCxvQkFBb0IsRUFBRSxLQUFLLEVBQUUsVUFBa0IsRUFBaUIsRUFBRTtRQUNoRSxJQUFJLE1BQU0sYUFBRSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDO1lBQUUsT0FBTTtRQUN4RCxNQUFN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QUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJ1xuaW1wb3J0IGdsb2IgZnJvbSAnZ2xvYidcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnXG5pbXBvcnQgeyB0c0NvbmZpZ0ZpbGVTZXJ2aWNlIH0gZnJvbSAnc3JjL3NlcnZpY2UvY29udmVydC90cy90cy1jb25maWctZmlsZS1zZXJ2aWNlJ1xuaW1wb3J0IHsgY29uc3RhbnQgfSBmcm9tICdzcmMvdXRpbC9jb25zdGFudCdcblxuY29uc3QgX3NlbGYgPSB7XG4gIGZpbGVMaXN0RnJvbUZvbGRlcjogYXN5bmMgKGZvbGRlclBhdGg6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+ID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nW10+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGN3ZCA9IF9zZWxmLnJlbGF0aXZlVG9BYnNQYXRoKGZvbGRlclBhdGgpXG4gICAgICBnbG9iKCcqKi8qJywgeyBjd2QsIGRvdDogdHJ1ZSwgbm9kaXI6IHRydWUsIGlnbm9yZTogJyoqLyoudGVzdC50cycgfSwgKGVyciwgZmlsZXMpID0+IHtcbiAgICAgICAgLy8gVE9ETyBpbXBsZW1lbnQgc29tZSBtZWNoYW5pc20gdG8gaWdub3JlIGZpbGVzXG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShmaWxlcy5tYXAoKGYpID0+IF9zZWxmLmpvaW5QYXRocyhmb2xkZXJQYXRoLCBmKSkpXG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG4gIG1ha2VGb2xkZXJJZk5vdEV4aXN0OiBhc3luYyAoZm9sZGVyUGF0aDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKGF3YWl0IGZzLnN0YXQoZm9sZGVyUGF0aCkuY2F0Y2goKCkgPT4gZmFsc2UpKSByZXR1cm5cbiAgICBhd2FpdCBmcy5ta2Rpcihmb2xkZXJQYXRoKVxuICB9LFxuICB3cml0ZVRvRmlsZTogYXN5bmMgKHBhcmFtczogeyBmaWxlUGF0aDogc3RyaW5nOyBkYXRhOiBzdHJpbmcgfSk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGNvbnN0IHsgZmlsZVBhdGgsIGRhdGEgfSA9IHBhcmFtc1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShmaWxlUGF0aCwgZGF0YSwgJ3V0Zi04JylcbiAgfSxcbiAgcmVhZEZpbGU6IGFzeW5jIChmaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGY4JylcbiAgfSxcbiAgbWtkaXJBbmRXcml0ZVRvRmlsZTogYXN5bmMgKHBhcmFtczogeyBmb2xkZXJQYXRoOiBzdHJpbmc7IGZpbGVOYW1lOiBzdHJpbmc7IGRhdGE6IHN0cmluZyB9KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgY29uc3QgeyBmb2xkZXJQYXRoLCBmaWxlTmFtZSwgZGF0YSB9ID0gcGFyYW1zXG4gICAgYXdhaXQgX3NlbGYubWFrZUZvbGRlcklmTm90RXhpc3QoZm9sZGVyUGF0aClcbiAgICBhd2FpdCBfc2VsZi53cml0ZVRvRmlsZSh7IGZpbGVQYXRoOiBfc2VsZi5qb2luUGF0aHMoZm9sZGVyUGF0aCwgZmlsZU5hbWUpLCBkYXRhIH0pXG4gIH0sXG4gIGpvaW5QYXRoczogKC4uLnBhdGhzOiBzdHJpbmdbXSk6IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIHBhdGguam9pbiguLi5wYXRocylcbiAgfSxcbiAgaXNBYnNQYXRoOiAocmVsYXRpdmVPckFic1BhdGg6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiByZWxhdGl2ZU9yQWJzUGF0aC5zdGFydHNXaXRoKGNvbnN0YW50LmZvbGRlclNlcClcbiAgfSxcbiAgaXNEb3RQYXRoOiAocGF0aDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgcmV0dXJuIHBhdGguc3RhcnRzV2l0aCgnLicpXG4gIH0sXG4gIHJlbGF0aXZlVG9BYnNQYXRoOiAocmVsYXRpdmVPckFic1BhdGg6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIF9zZWxmLmlzQWJzUGF0aChyZWxhdGl2ZU9yQWJzUGF0aCkgPyByZWxhdGl2ZU9yQWJzUGF0aCA6IF9zZWxmLmpvaW5QYXRocyhwcm9jZXNzLmN3ZCgpLCByZWxhdGl2ZU9yQWJzUGF0aClcbiAgfSxcbiAgY2xlYW51cFBhdGg6IChyZWxhdGl2ZU9yQWJzUGF0aDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICByZXR1cm4gcGF0aC5qb2luKHJlbGF0aXZlT3JBYnNQYXRoKVxuICB9LFxuICBsYXN0Rm9sZGVyRnJvbVBhdGg6IChmaWxlUGF0aDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICBjb25zdCBwYXRoU3BsaXQgPSBmaWxlUGF0aC5zcGxpdChjb25zdGFudC5mb2xkZXJTZXApXG4gICAgaWYgKHBhdGhTcGxpdFtwYXRoU3BsaXQubGVuZ3RoIC0gMV0uaW5jbHVkZXMoJy4nKSkgcGF0aFNwbGl0LnBvcCgpXG4gICAgcmV0dXJuIHBhdGhTcGxpdC5qb2luKGNvbnN0YW50LmZvbGRlclNlcClcbiAgfSxcbiAgaW1wb3J0UGF0aEZpbmQ6IChwYXJhbXM6IHsgZmlsZVBhdGhJbXBvcnRlZEZyb206IHN0cmluZzsgaW1wb3J0UGF0aDogc3RyaW5nIH0pOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IHsgZmlsZVBhdGhJbXBvcnRlZEZyb20sIGltcG9ydFBhdGggfSA9IHBhcmFtc1xuICAgIGNvbnN0IHJlc29sdmVkSW1wb3J0UGF0aCA9IHRzQ29uZmlnRmlsZVNlcnZpY2UubW9kdWxlQWxpYXNSZXNvbHZlKGltcG9ydFBhdGgpXG4gICAgY29uc3QgaW1wb3J0ZWRGcm9tUGF0aCA9IF9zZWxmLmxhc3RGb2xkZXJGcm9tUGF0aChmaWxlUGF0aEltcG9ydGVkRnJvbSlcbiAgICBjb25zdCBpbXBvcnRQYXRoU3BsaXQgPSByZXNvbHZlZEltcG9ydFBhdGguc3BsaXQoY29uc3RhbnQuZm9sZGVyU2VwKVxuICAgIGNvbnN0IGltcG9ydGVkRnJvbVBhdGhSZXZlcnNlU3BsaXQgPSBpbXBvcnRlZEZyb21QYXRoLnNwbGl0KGNvbnN0YW50LmZvbGRlclNlcCkucmV2ZXJzZSgpXG4gICAgbGV0IGVxdWFsUGF0aFNwbGl0Q291bnQgPSAwXG4gICAgZm9yIChjb25zdCBbaXgsIHNwbGl0XSBvZiBPYmplY3QuZW50cmllcyhpbXBvcnRQYXRoU3BsaXQpKSB7XG4gICAgICBpZiAoaW1wb3J0ZWRGcm9tUGF0aFJldmVyc2VTcGxpdFtpeF0gIT09IHNwbGl0KSBicmVha1xuICAgICAgZXF1YWxQYXRoU3BsaXRDb3VudCA9ICtpeCArIDFcbiAgICB9XG4gICAgY29uc3QgY2xlYW5JbXBvcnRQYXRoID0gaW1wb3J0UGF0aFNwbGl0LnNsaWNlKGVxdWFsUGF0aFNwbGl0Q291bnQpLmpvaW4oY29uc3RhbnQuZm9sZGVyU2VwKVxuICAgIHJldHVybiBfc2VsZi5qb2luUGF0aHMoaW1wb3J0ZWRGcm9tUGF0aCwgY2xlYW5JbXBvcnRQYXRoKVxuICB9LFxuICBmaWxlTmFtZUZyb21QYXRoOiAoZmlsZVBhdGg6IHN0cmluZywgb3B0aW9uczogeyB3aXRoRXh0ZW5zaW9uPzogYm9vbGVhbiB9ID0ge30pOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IHBhcnRzID0gZmlsZVBhdGguc3BsaXQoY29uc3RhbnQuZm9sZGVyU2VwKVxuICAgIGNvbnN0IGxhc3RQYXJ0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV1cbiAgICBpZiAob3B0aW9ucy53aXRoRXh0ZW5zaW9uKSByZXR1cm4gbGFzdFBhcnRcbiAgICBjb25zdCBuYW1lUGFydHMgPSBsYXN0UGFydC5zcGxpdCgnLicpXG4gICAgaWYgKG5hbWVQYXJ0cy5sZW5ndGggPT09IDEpIHJldHVybiBuYW1lUGFydHNbMF1cbiAgICBuYW1lUGFydHMucG9wKClcbiAgICByZXR1cm4gbmFtZVBhcnRzLmpvaW4oJy4nKVxuICB9LFxufVxuXG5leHBvcnQgY29uc3QgZmlsZVNlcnZpY2UgPSBfc2VsZlxuIl19