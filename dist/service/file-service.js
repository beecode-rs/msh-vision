"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fileService = void 0;
const fs_1 = require("fs");
const glob_1 = __importDefault(require("glob"));
const path_1 = __importDefault(require("path"));
const ts_config_file_service_1 = require("src/service/convert-ts/ts-config-file-service");
const constant_1 = require("src/util/constant");
const _self = {
    fileListFromFolder: async (folderPath) => {
        return new Promise((resolve, reject) => {
            const cwd = _self.relativeToAbsPath(folderPath);
            (0, glob_1.default)('**/*', { cwd, dot: true, nodir: true, ignore: ['**/*.test.ts', '**/*.contract.ts'] }, (err, files) => {
                // TODO implement some mechanism to ignore files
                if (err)
                    return reject(err);
                return resolve(files.map((f) => _self.joinPaths(folderPath, f)));
            });
        });
    },
    makeFolderIfNotExist: async (folderPath) => {
        if (await fs_1.promises.stat(folderPath).catch(() => false))
            return;
        await fs_1.promises.mkdir(folderPath);
    },
    writeToFile: async (params) => {
        const { filePath, data } = params;
        await fs_1.promises.writeFile(filePath, data, 'utf-8');
    },
    readFile: async (filePath) => {
        return fs_1.promises.readFile(filePath, 'utf8');
    },
    mkdirAndWriteToFile: async (params) => {
        const { folderPath, fileName, data } = params;
        await _self.makeFolderIfNotExist(folderPath);
        await _self.writeToFile({ filePath: _self.joinPaths(folderPath, fileName), data });
    },
    joinPaths: (...paths) => {
        return path_1.default.join(...paths);
    },
    isAbsPath: (relativeOrAbsPath) => {
        return relativeOrAbsPath.startsWith(constant_1.constant.folderSep);
    },
    isDotPath: (path) => {
        return path.startsWith('.');
    },
    relativeToAbsPath: (relativeOrAbsPath) => {
        return _self.isAbsPath(relativeOrAbsPath) ? relativeOrAbsPath : _self.joinPaths(process.cwd(), relativeOrAbsPath);
    },
    cleanupPath: (relativeOrAbsPath) => {
        return path_1.default.join(relativeOrAbsPath);
    },
    lastFolderFromPath: (filePath) => {
        const pathSplit = filePath.split(constant_1.constant.folderSep);
        if (pathSplit[pathSplit.length - 1].includes('.'))
            pathSplit.pop();
        return pathSplit.join(constant_1.constant.folderSep);
    },
    importPathFind: (params) => {
        const { filePathImportedFrom, importPath } = params;
        const resolvedImportPath = ts_config_file_service_1.tsConfigFileService.moduleAliasResolve(importPath);
        const importedFromPath = _self.lastFolderFromPath(filePathImportedFrom);
        const importPathSplit = resolvedImportPath.split(constant_1.constant.folderSep);
        const importedFromPathReverseSplit = importedFromPath.split(constant_1.constant.folderSep).reverse();
        let equalPathSplitCount = 0;
        for (const [ix, split] of Object.entries(importPathSplit)) {
            if (importedFromPathReverseSplit[ix] !== split)
                break;
            equalPathSplitCount = +ix + 1;
        }
        const cleanImportPath = importPathSplit.slice(equalPathSplitCount).join(constant_1.constant.folderSep);
        return _self.joinPaths(importedFromPath, cleanImportPath);
    },
    fileNameFromPath: (filePath, options = {}) => {
        const parts = filePath.split(constant_1.constant.folderSep);
        const lastPart = parts[parts.length - 1];
        if (options.withExtension)
            return lastPart;
        const nameParts = lastPart.split('.');
        if (nameParts.length === 1)
            return nameParts[0];
        nameParts.pop();
        return nameParts.join('.');
    },
};
exports.fileService = _self;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZS1zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3NlcnZpY2UvZmlsZS1zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDJCQUFtQztBQUNuQyxnREFBdUI7QUFDdkIsZ0RBQXVCO0FBQ3ZCLDBGQUFtRjtBQUNuRixnREFBNEM7QUFFNUMsTUFBTSxLQUFLLEdBQUc7SUFDWixrQkFBa0IsRUFBRSxLQUFLLEVBQUUsVUFBa0IsRUFBcUIsRUFBRTtRQUNsRSxPQUFPLElBQUksT0FBTyxDQUFXLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO1lBQy9DLE1BQU0sR0FBRyxHQUFHLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsQ0FBQTtZQUMvQyxJQUFBLGNBQUksRUFBQyxNQUFNLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDLGNBQWMsRUFBRSxrQkFBa0IsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLEVBQUU7Z0JBQ3pHLGdEQUFnRDtnQkFDaEQsSUFBSSxHQUFHO29CQUFFLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFBO2dCQUMzQixPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7WUFDbEUsQ0FBQyxDQUFDLENBQUE7UUFDSixDQUFDLENBQUMsQ0FBQTtJQUNKLENBQUM7SUFDRCxvQkFBb0IsRUFBRSxLQUFLLEVBQUUsVUFBa0IsRUFBaUIsRUFBRTtRQUNoRSxJQUFJLE1BQU0sYUFBRSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUMsS0FB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QUFFWSxRQUFBLFdBQVcsR0FBRyxLQUFLLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJ1xuaW1wb3J0IGdsb2IgZnJvbSAnZ2xvYidcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnXG5pbXBvcnQgeyB0c0NvbmZpZ0ZpbGVTZXJ2aWNlIH0gZnJvbSAnc3JjL3NlcnZpY2UvY29udmVydC10cy90cy1jb25maWctZmlsZS1zZXJ2aWNlJ1xuaW1wb3J0IHsgY29uc3RhbnQgfSBmcm9tICdzcmMvdXRpbC9jb25zdGFudCdcblxuY29uc3QgX3NlbGYgPSB7XG4gIGZpbGVMaXN0RnJvbUZvbGRlcjogYXN5bmMgKGZvbGRlclBhdGg6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+ID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nW10+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGN3ZCA9IF9zZWxmLnJlbGF0aXZlVG9BYnNQYXRoKGZvbGRlclBhdGgpXG4gICAgICBnbG9iKCcqKi8qJywgeyBjd2QsIGRvdDogdHJ1ZSwgbm9kaXI6IHRydWUsIGlnbm9yZTogWycqKi8qLnRlc3QudHMnLCAnKiovKi5jb250cmFjdC50cyddIH0sIChlcnIsIGZpbGVzKSA9PiB7XG4gICAgICAgIC8vIFRPRE8gaW1wbGVtZW50IHNvbWUgbWVjaGFuaXNtIHRvIGlnbm9yZSBmaWxlc1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoZmlsZXMubWFwKChmKSA9PiBfc2VsZi5qb2luUGF0aHMoZm9sZGVyUGF0aCwgZikpKVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuICBtYWtlRm9sZGVySWZOb3RFeGlzdDogYXN5bmMgKGZvbGRlclBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmIChhd2FpdCBmcy5zdGF0KGZvbGRlclBhdGgpLmNhdGNoKCgpID0+IGZhbHNlKSkgcmV0dXJuXG4gICAgYXdhaXQgZnMubWtkaXIoZm9sZGVyUGF0aClcbiAgfSxcbiAgd3JpdGVUb0ZpbGU6IGFzeW5jIChwYXJhbXM6IHsgZmlsZVBhdGg6IHN0cmluZzsgZGF0YTogc3RyaW5nIH0pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBjb25zdCB7IGZpbGVQYXRoLCBkYXRhIH0gPSBwYXJhbXNcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZmlsZVBhdGgsIGRhdGEsICd1dGYtOCcpXG4gIH0sXG4gIHJlYWRGaWxlOiBhc3luYyAoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlKGZpbGVQYXRoLCAndXRmOCcpXG4gIH0sXG4gIG1rZGlyQW5kV3JpdGVUb0ZpbGU6IGFzeW5jIChwYXJhbXM6IHsgZm9sZGVyUGF0aDogc3RyaW5nOyBmaWxlTmFtZTogc3RyaW5nOyBkYXRhOiBzdHJpbmcgfSk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGNvbnN0IHsgZm9sZGVyUGF0aCwgZmlsZU5hbWUsIGRhdGEgfSA9IHBhcmFtc1xuICAgIGF3YWl0IF9zZWxmLm1ha2VGb2xkZXJJZk5vdEV4aXN0KGZvbGRlclBhdGgpXG4gICAgYXdhaXQgX3NlbGYud3JpdGVUb0ZpbGUoeyBmaWxlUGF0aDogX3NlbGYuam9pblBhdGhzKGZvbGRlclBhdGgsIGZpbGVOYW1lKSwgZGF0YSB9KVxuICB9LFxuICBqb2luUGF0aHM6ICguLi5wYXRoczogc3RyaW5nW10pOiBzdHJpbmcgPT4ge1xuICAgIHJldHVybiBwYXRoLmpvaW4oLi4ucGF0aHMpXG4gIH0sXG4gIGlzQWJzUGF0aDogKHJlbGF0aXZlT3JBYnNQYXRoOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICByZXR1cm4gcmVsYXRpdmVPckFic1BhdGguc3RhcnRzV2l0aChjb25zdGFudC5mb2xkZXJTZXApXG4gIH0sXG4gIGlzRG90UGF0aDogKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiBwYXRoLnN0YXJ0c1dpdGgoJy4nKVxuICB9LFxuICByZWxhdGl2ZVRvQWJzUGF0aDogKHJlbGF0aXZlT3JBYnNQYXRoOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgIHJldHVybiBfc2VsZi5pc0Fic1BhdGgocmVsYXRpdmVPckFic1BhdGgpID8gcmVsYXRpdmVPckFic1BhdGggOiBfc2VsZi5qb2luUGF0aHMocHJvY2Vzcy5jd2QoKSwgcmVsYXRpdmVPckFic1BhdGgpXG4gIH0sXG4gIGNsZWFudXBQYXRoOiAocmVsYXRpdmVPckFic1BhdGg6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIHBhdGguam9pbihyZWxhdGl2ZU9yQWJzUGF0aClcbiAgfSxcbiAgbGFzdEZvbGRlckZyb21QYXRoOiAoZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgY29uc3QgcGF0aFNwbGl0ID0gZmlsZVBhdGguc3BsaXQoY29uc3RhbnQuZm9sZGVyU2VwKVxuICAgIGlmIChwYXRoU3BsaXRbcGF0aFNwbGl0Lmxlbmd0aCAtIDFdLmluY2x1ZGVzKCcuJykpIHBhdGhTcGxpdC5wb3AoKVxuICAgIHJldHVybiBwYXRoU3BsaXQuam9pbihjb25zdGFudC5mb2xkZXJTZXApXG4gIH0sXG4gIGltcG9ydFBhdGhGaW5kOiAocGFyYW1zOiB7IGZpbGVQYXRoSW1wb3J0ZWRGcm9tOiBzdHJpbmc7IGltcG9ydFBhdGg6IHN0cmluZyB9KTogc3RyaW5nID0+IHtcbiAgICBjb25zdCB7IGZpbGVQYXRoSW1wb3J0ZWRGcm9tLCBpbXBvcnRQYXRoIH0gPSBwYXJhbXNcbiAgICBjb25zdCByZXNvbHZlZEltcG9ydFBhdGggPSB0c0NvbmZpZ0ZpbGVTZXJ2aWNlLm1vZHVsZUFsaWFzUmVzb2x2ZShpbXBvcnRQYXRoKVxuICAgIGNvbnN0IGltcG9ydGVkRnJvbVBhdGggPSBfc2VsZi5sYXN0Rm9sZGVyRnJvbVBhdGgoZmlsZVBhdGhJbXBvcnRlZEZyb20pXG4gICAgY29uc3QgaW1wb3J0UGF0aFNwbGl0ID0gcmVzb2x2ZWRJbXBvcnRQYXRoLnNwbGl0KGNvbnN0YW50LmZvbGRlclNlcClcbiAgICBjb25zdCBpbXBvcnRlZEZyb21QYXRoUmV2ZXJzZVNwbGl0ID0gaW1wb3J0ZWRGcm9tUGF0aC5zcGxpdChjb25zdGFudC5mb2xkZXJTZXApLnJldmVyc2UoKVxuICAgIGxldCBlcXVhbFBhdGhTcGxpdENvdW50ID0gMFxuICAgIGZvciAoY29uc3QgW2l4LCBzcGxpdF0gb2YgT2JqZWN0LmVudHJpZXMoaW1wb3J0UGF0aFNwbGl0KSkge1xuICAgICAgaWYgKGltcG9ydGVkRnJvbVBhdGhSZXZlcnNlU3BsaXRbaXhdICE9PSBzcGxpdCkgYnJlYWtcbiAgICAgIGVxdWFsUGF0aFNwbGl0Q291bnQgPSAraXggKyAxXG4gICAgfVxuICAgIGNvbnN0IGNsZWFuSW1wb3J0UGF0aCA9IGltcG9ydFBhdGhTcGxpdC5zbGljZShlcXVhbFBhdGhTcGxpdENvdW50KS5qb2luKGNvbnN0YW50LmZvbGRlclNlcClcbiAgICByZXR1cm4gX3NlbGYuam9pblBhdGhzKGltcG9ydGVkRnJvbVBhdGgsIGNsZWFuSW1wb3J0UGF0aClcbiAgfSxcbiAgZmlsZU5hbWVGcm9tUGF0aDogKGZpbGVQYXRoOiBzdHJpbmcsIG9wdGlvbnM6IHsgd2l0aEV4dGVuc2lvbj86IGJvb2xlYW4gfSA9IHt9KTogc3RyaW5nID0+IHtcbiAgICBjb25zdCBwYXJ0cyA9IGZpbGVQYXRoLnNwbGl0KGNvbnN0YW50LmZvbGRlclNlcClcbiAgICBjb25zdCBsYXN0UGFydCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdXG4gICAgaWYgKG9wdGlvbnMud2l0aEV4dGVuc2lvbikgcmV0dXJuIGxhc3RQYXJ0XG4gICAgY29uc3QgbmFtZVBhcnRzID0gbGFzdFBhcnQuc3BsaXQoJy4nKVxuICAgIGlmIChuYW1lUGFydHMubGVuZ3RoID09PSAxKSByZXR1cm4gbmFtZVBhcnRzWzBdXG4gICAgbmFtZVBhcnRzLnBvcCgpXG4gICAgcmV0dXJuIG5hbWVQYXJ0cy5qb2luKCcuJylcbiAgfSxcbn1cblxuZXhwb3J0IGNvbnN0IGZpbGVTZXJ2aWNlID0gX3NlbGZcbiJdfQ==