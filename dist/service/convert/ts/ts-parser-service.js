"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tsParserService = void 0;
const reference_type_1 = require("src/enum/reference-type");
const property_1 = require("src/model/property");
const reference_1 = require("src/model/reference");
const ts_1 = __importDefault(require("src/module/ts"));
const ts_parser_import_1 = require("src/service/convert/ts/parser/ts-parser-import");
const logger_1 = require("src/util/logger");
const _self = {
    isExported: (modifiers) => {
        if (!modifiers)
            return false;
        return !!modifiers.find((m) => m.kind === ts_1.default.SyntaxKind.ExportKeyword);
    },
    isAbstract: (modifiers) => {
        if (!modifiers)
            return false;
        return !!modifiers.find((m) => m.kind === ts_1.default.SyntaxKind.AbstractKeyword);
    },
    accessLevel: (modifiers) => {
        if (!modifiers)
            return property_1.PropertyAccessLevelType.NO_MODIFIER;
        if (modifiers.find((m) => m.kind === ts_1.default.SyntaxKind.PublicKeyword))
            return property_1.PropertyAccessLevelType.PUBLIC;
        if (modifiers.find((m) => m.kind === ts_1.default.SyntaxKind.PrivateKeyword))
            return property_1.PropertyAccessLevelType.PRIVATE;
        if (modifiers.find((m) => m.kind === ts_1.default.SyntaxKind.ProtectedKeyword))
            return property_1.PropertyAccessLevelType.PROTECTED;
        return property_1.PropertyAccessLevelType.NO_MODIFIER;
    },
    nameFromDeclarationsList: (declarationList) => {
        if (!declarationList?.declarations)
            return;
        const decl = declarationList.declarations.find((d) => d.name);
        if (!decl)
            return;
        return {
            name: decl.name['escapedText'],
            declaration: decl,
        };
    },
    checkIfThereAreAnyExports: (parsedSource) => {
        return !!parsedSource.statements.find((s) => _self._isViableExportableStatementKind(s.kind) && _self.isExported(s.modifiers));
    },
    _isViableExportableStatementKind: (kind) => {
        return [
            ts_1.default.SyntaxKind.TypeAliasDeclaration,
            ts_1.default.SyntaxKind.ClassDeclaration,
            ts_1.default.SyntaxKind.InterfaceDeclaration,
            ts_1.default.SyntaxKind.VariableDeclaration,
            ts_1.default.SyntaxKind.VariableStatement,
            ts_1.default.SyntaxKind.VariableDeclarationList,
            ts_1.default.SyntaxKind.EnumDeclaration,
        ].includes(kind);
    },
    findClassRelations: (params) => {
        const { statement, parsedSource, inProjectPath } = params;
        const extendImplements = (statement['heritageClauses'] ?? [])
            .map((heritage) => {
            const type = heritage.getText(parsedSource).split(' ')[0];
            return (heritage.types ?? []).map((t) => ({ type, name: t.expression.escapedText }));
        })
            .flat();
        if (extendImplements.length === 0)
            return [];
        const fileImports = parsedSource.statements
            .map((statement) => new ts_parser_import_1.TsParserImport({ statement, inProjectPath }).parse())
            .flat();
        return extendImplements
            .map((ei) => {
            const fileImport = fileImports.find((fi) => {
                return fi.name === ei.name;
            });
            if (!fileImport) {
                logger_1.logger.warn(`Import not found for ${JSON.stringify(ei)}`);
                return;
            }
            return new reference_1.Reference({
                name: ei.name,
                type: ei.type === 'implements' ? reference_type_1.ReferenceType.IMPLEMENTATION : reference_type_1.ReferenceType.INHERITANCE,
                inProjectPath: fileImport.inProjectPath,
            });
        })
            .filter(Boolean);
    },
};
exports.tsParserService = _self;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHMtcGFyc2VyLXNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvc2VydmljZS9jb252ZXJ0L3RzL3RzLXBhcnNlci1zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDREQUF1RDtBQUN2RCxpREFBNEQ7QUFDNUQsbURBQStDO0FBQy9DLHVEQUE4QjtBQUM5QixxRkFBK0U7QUFDL0UsNENBQXdDO0FBRXhDLE1BQU0sS0FBSyxHQUFHO0lBQ1osVUFBVSxFQUFFLENBQUMsU0FBNkIsRUFBVyxFQUFFO1FBQ3JELElBQUksQ0FBQyxTQUFTO1lBQUUsT0FBTyxLQUFLLENBQUE7UUFDNUIsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxZQUFFLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxDQUFBO0lBQ3hFLENBQUM7SUFDRCxVQUFVLEVBQUUsQ0FBQyxTQUE2QixFQUFXLEVBQUU7UUFDckQsSUFBSSxDQUFDLFNBQVM7WUFBRSxPQUFPLEtBQUssQ0FBQTtRQUM1QixPQUFPLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLFlBQUUsQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDLENBQUE7SUFDMUUsQ0FBQztJQUNELFdBQVcsRUFBRSxDQUFDLFNBQTZCLEVBQTJCLEVBQUU7UUFDdEUsSUFBSSxDQUFDLFNBQVM7WUFBRSxPQUFPLGtDQUF1QixDQUFDLFdBQVcsQ0FBQTtRQUMxRCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssWUFBRSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7WUFBRSxPQUFPLGtDQUF1QixDQUFDLE1BQU0sQ0FB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QUFFLENBQUMsSUFBSSxpQ0FBYyxDQUFDLEVBQUUsU0FBUyxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUM7YUFDNUUsSUFBSSxFQUFFLENBQUE7UUFFVCxPQUFPLGdCQUFnQjthQUNwQixHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRTtZQUNWLE1BQU0sVUFBVSxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRTtnQkFDekMsT0FBTyxFQUFFLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUE7WUFDNUIsQ0FBQyxDQUFDLENBQUE7WUFDRixJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUNmLGVBQU0sQ0FBQyxJQUFJLENBQUMsd0JBQXdCLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFBO2dCQUN6RCxPQUFNO2FBQ1A7WUFDRCxPQUFPLElBQUkscUJBQVMsQ0FBQztnQkFDbkIsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJO2dCQUNiLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxLQUFLLFlBQVksQ0FBQyxDQUFDLENBQUMsOEJBQWEsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLDhCQUFhLENBQUMsV0FBVztnQkFDekYsYUFBYSxFQUFFLFVBQVUsQ0FBQyxhQUFhO2FBQ3hDLENBQUMsQ0FBQTtRQUNKLENBQUMsQ0FBQzthQUNELE1BQU0sQ0FBQyxPQUFPLENBQWdCLENBQUE7SUFDbkMsQ0FBQztDQUNGLENBQUE7QUFFWSxRQUFBLGVBQWUsR0FBRyxLQUFLLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZWZlcmVuY2VUeXBlIH0gZnJvbSAnc3JjL2VudW0vcmVmZXJlbmNlLXR5cGUnXG5pbXBvcnQgeyBQcm9wZXJ0eUFjY2Vzc0xldmVsVHlwZSB9IGZyb20gJ3NyYy9tb2RlbC9wcm9wZXJ0eSdcbmltcG9ydCB7IFJlZmVyZW5jZSB9IGZyb20gJ3NyYy9tb2RlbC9yZWZlcmVuY2UnXG5pbXBvcnQgdHMgZnJvbSAnc3JjL21vZHVsZS90cydcbmltcG9ydCB7IFRzUGFyc2VySW1wb3J0IH0gZnJvbSAnc3JjL3NlcnZpY2UvY29udmVydC90cy9wYXJzZXIvdHMtcGFyc2VyLWltcG9ydCdcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJ3NyYy91dGlsL2xvZ2dlcidcblxuY29uc3QgX3NlbGYgPSB7XG4gIGlzRXhwb3J0ZWQ6IChtb2RpZmllcnM/OiB0cy5Nb2RpZmllcnNBcnJheSk6IGJvb2xlYW4gPT4ge1xuICAgIGlmICghbW9kaWZpZXJzKSByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gISFtb2RpZmllcnMuZmluZCgobSkgPT4gbS5raW5kID09PSB0cy5TeW50YXhLaW5kLkV4cG9ydEtleXdvcmQpXG4gIH0sXG4gIGlzQWJzdHJhY3Q6IChtb2RpZmllcnM/OiB0cy5Nb2RpZmllcnNBcnJheSk6IGJvb2xlYW4gPT4ge1xuICAgIGlmICghbW9kaWZpZXJzKSByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gISFtb2RpZmllcnMuZmluZCgobSkgPT4gbS5raW5kID09PSB0cy5TeW50YXhLaW5kLkFic3RyYWN0S2V5d29yZClcbiAgfSxcbiAgYWNjZXNzTGV2ZWw6IChtb2RpZmllcnM/OiB0cy5Nb2RpZmllcnNBcnJheSk6IFByb3BlcnR5QWNjZXNzTGV2ZWxUeXBlID0+IHtcbiAgICBpZiAoIW1vZGlmaWVycykgcmV0dXJuIFByb3BlcnR5QWNjZXNzTGV2ZWxUeXBlLk5PX01PRElGSUVSXG4gICAgaWYgKG1vZGlmaWVycy5maW5kKChtKSA9PiBtLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuUHVibGljS2V5d29yZCkpIHJldHVybiBQcm9wZXJ0eUFjY2Vzc0xldmVsVHlwZS5QVUJMSUNcbiAgICBpZiAobW9kaWZpZXJzLmZpbmQoKG0pID0+IG0ua2luZCA9PT0gdHMuU3ludGF4S2luZC5Qcml2YXRlS2V5d29yZCkpIHJldHVybiBQcm9wZXJ0eUFjY2Vzc0xldmVsVHlwZS5QUklWQVRFXG4gICAgaWYgKG1vZGlmaWVycy5maW5kKChtKSA9PiBtLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuUHJvdGVjdGVkS2V5d29yZCkpIHJldHVybiBQcm9wZXJ0eUFjY2Vzc0xldmVsVHlwZS5QUk9URUNURURcbiAgICByZXR1cm4gUHJvcGVydHlBY2Nlc3NMZXZlbFR5cGUuTk9fTU9ESUZJRVJcbiAgfSxcblxuICBuYW1lRnJvbURlY2xhcmF0aW9uc0xpc3Q6IChcbiAgICBkZWNsYXJhdGlvbkxpc3Q6IHRzLlZhcmlhYmxlRGVjbGFyYXRpb25MaXN0XG4gICk6IHsgbmFtZTogc3RyaW5nOyBkZWNsYXJhdGlvbjogdHMuVmFyaWFibGVEZWNsYXJhdGlvbiB9IHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAoIWRlY2xhcmF0aW9uTGlzdD8uZGVjbGFyYXRpb25zKSByZXR1cm5cbiAgICBjb25zdCBkZWNsID0gZGVjbGFyYXRpb25MaXN0LmRlY2xhcmF0aW9ucy5maW5kKChkKSA9PiBkLm5hbWUpXG4gICAgaWYgKCFkZWNsKSByZXR1cm5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogZGVjbC5uYW1lWydlc2NhcGVkVGV4dCddLFxuICAgICAgZGVjbGFyYXRpb246IGRlY2wsXG4gICAgfVxuICB9LFxuICBjaGVja0lmVGhlcmVBcmVBbnlFeHBvcnRzOiAocGFyc2VkU291cmNlOiB0cy5Tb3VyY2VGaWxlKTogYm9vbGVhbiA9PiB7XG4gICAgcmV0dXJuICEhcGFyc2VkU291cmNlLnN0YXRlbWVudHMuZmluZCgocykgPT4gX3NlbGYuX2lzVmlhYmxlRXhwb3J0YWJsZVN0YXRlbWVudEtpbmQocy5raW5kKSAmJiBfc2VsZi5pc0V4cG9ydGVkKHMubW9kaWZpZXJzKSlcbiAgfSxcbiAgX2lzVmlhYmxlRXhwb3J0YWJsZVN0YXRlbWVudEtpbmQ6IChraW5kOiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgICByZXR1cm4gW1xuICAgICAgdHMuU3ludGF4S2luZC5UeXBlQWxpYXNEZWNsYXJhdGlvbixcbiAgICAgIHRzLlN5bnRheEtpbmQuQ2xhc3NEZWNsYXJhdGlvbixcbiAgICAgIHRzLlN5bnRheEtpbmQuSW50ZXJmYWNlRGVjbGFyYXRpb24sXG4gICAgICB0cy5TeW50YXhLaW5kLlZhcmlhYmxlRGVjbGFyYXRpb24sXG4gICAgICB0cy5TeW50YXhLaW5kLlZhcmlhYmxlU3RhdGVtZW50LFxuICAgICAgdHMuU3ludGF4S2luZC5WYXJpYWJsZURlY2xhcmF0aW9uTGlzdCxcbiAgICAgIHRzLlN5bnRheEtpbmQuRW51bURlY2xhcmF0aW9uLFxuICAgIF0uaW5jbHVkZXMoa2luZClcbiAgfSxcbiAgZmluZENsYXNzUmVsYXRpb25zOiAocGFyYW1zOiB7IHN0YXRlbWVudDogdHMuU3RhdGVtZW50OyBwYXJzZWRTb3VyY2U6IHRzLlNvdXJjZUZpbGU7IGluUHJvamVjdFBhdGg6IHN0cmluZyB9KTogUmVmZXJlbmNlW10gPT4ge1xuICAgIGNvbnN0IHsgc3RhdGVtZW50LCBwYXJzZWRTb3VyY2UsIGluUHJvamVjdFBhdGggfSA9IHBhcmFtc1xuICAgIGNvbnN0IGV4dGVuZEltcGxlbWVudHMgPSAoc3RhdGVtZW50WydoZXJpdGFnZUNsYXVzZXMnXSA/PyBbXSlcbiAgICAgIC5tYXAoKGhlcml0YWdlKSA9PiB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBoZXJpdGFnZS5nZXRUZXh0KHBhcnNlZFNvdXJjZSkuc3BsaXQoJyAnKVswXVxuICAgICAgICByZXR1cm4gKGhlcml0YWdlLnR5cGVzID8/IFtdKS5tYXAoKHQpID0+ICh7IHR5cGUsIG5hbWU6IHQuZXhwcmVzc2lvbi5lc2NhcGVkVGV4dCB9KSlcbiAgICAgIH0pXG4gICAgICAuZmxhdCgpIGFzIHsgdHlwZTogJ2ltcGxlbWVudHMnIHwgJ2V4dGVuZHMnOyBuYW1lOiBzdHJpbmcgfVtdXG4gICAgaWYgKGV4dGVuZEltcGxlbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gW11cblxuICAgIGNvbnN0IGZpbGVJbXBvcnRzID0gcGFyc2VkU291cmNlLnN0YXRlbWVudHNcbiAgICAgIC5tYXAoKHN0YXRlbWVudCkgPT4gbmV3IFRzUGFyc2VySW1wb3J0KHsgc3RhdGVtZW50LCBpblByb2plY3RQYXRoIH0pLnBhcnNlKCkpXG4gICAgICAuZmxhdCgpXG5cbiAgICByZXR1cm4gZXh0ZW5kSW1wbGVtZW50c1xuICAgICAgLm1hcCgoZWkpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZUltcG9ydCA9IGZpbGVJbXBvcnRzLmZpbmQoKGZpKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGZpLm5hbWUgPT09IGVpLm5hbWVcbiAgICAgICAgfSlcbiAgICAgICAgaWYgKCFmaWxlSW1wb3J0KSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4oYEltcG9ydCBub3QgZm91bmQgZm9yICR7SlNPTi5zdHJpbmdpZnkoZWkpfWApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZWZlcmVuY2Uoe1xuICAgICAgICAgIG5hbWU6IGVpLm5hbWUsXG4gICAgICAgICAgdHlwZTogZWkudHlwZSA9PT0gJ2ltcGxlbWVudHMnID8gUmVmZXJlbmNlVHlwZS5JTVBMRU1FTlRBVElPTiA6IFJlZmVyZW5jZVR5cGUuSU5IRVJJVEFOQ0UsXG4gICAgICAgICAgaW5Qcm9qZWN0UGF0aDogZmlsZUltcG9ydC5pblByb2plY3RQYXRoLFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoQm9vbGVhbikgYXMgUmVmZXJlbmNlW11cbiAgfSxcbn1cblxuZXhwb3J0IGNvbnN0IHRzUGFyc2VyU2VydmljZSA9IF9zZWxmXG4iXX0=